// VS Code User snippets file for C++, usually placed in %APPDATA%\Code\User\snippets\
// Possible variables are: $1, $2 for tab stops, $0 for the final cursor position, and
// ${1:label}, ${2:another} for placeholders. Placeholders with the same ids are connected.
{
    "for CP with testcases": {
        "prefix": "tcCompi",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "#define fi(n) for (int i = 0; i < n; ++i)",
            "#define fj(n) for (int j = 0; j < n; ++j)",
            "",
            "using namespace std;",
            "using ll = long long;",
            "using vi = vector<int>;",
            "using vvi = vector<vi>;",
            "",
            "void solve() {",
            "\tint n;",
            "\tcin >> n;",
            "\t$0",
            "}",
            "",
            "int main() {",
            "\tios_base::sync_with_stdio(false);",
            "\tcin.tie(nullptr);",
            "\tint tc;",
            "\tcin >> tc;",
            "\tfi(tc) solve();",
            "\treturn 0;",
            "}"
        ],
        "description": "CP snippet with testcases"
    },
    "for CP without testcases": {
        "prefix": "ntCompi",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "#define fi(n) for (int i = 0; i < n; ++i)",
            "#define fj(n) for (int j = 0; j < n; ++j)",
            "",
            "using namespace std;",
            "using ll = long long;",
            "using vi = vector<int>;",
            "using vvi = vector<vi>;",
            "",
            "void solve() {",
            "\tint n;",
            "\tcin >> n;",
            "\t$0",
            "}",
            "",
            "int main() {",
            "\tios_base::sync_with_stdio(false);",
            "\tcin.tie(nullptr);",
            "\tsolve();",
            "\treturn 0;",
            "}"
        ],
        "description": "CP snippet without test cases"
    },
    "for CP with modulo arithmetic": {
        "prefix": "mCompi",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "#define MOD 1'000'000'007 // 998'244'353",
            "#define fi(n) for (int i = 0; i < n; ++i)",
            "#define fj(n) for (int j = 0; j < n; ++j)",
            "",
            "using namespace std;",
            "using ll = long long;",
            "using vi = vector<int>;",
            "using vvi = vector<vi>;",
            "",
            "vi fact(500'001);",
            "ll power(ll base, ll exp);",
            "ll invM(ll a);",
            "ll nPr(int n, int r);",
            "ll nCr(int n, int r);",
            "",
            "void solve() {",
            "\tint n;",
            "\tcin >> n;",
            "\t$0",
            "}",
            "",
            "int main() {",
            "\tios_base::sync_with_stdio(false);",
            "\tcin.tie(nullptr);",
            "\tfact[0] = 1;",
            "\tfi(fact.size() - 1) fact[i + 1] = (ll)(i + 1) * fact[i] % MOD;",
            "\tint tc;",
            "\tcin >> tc;",
            "\tfi(tc) solve();",
            "\treturn 0;",
            "}",
            "",
            "ll power(ll a, ll b) {",
            "\tll c = 1;",
            "\ta %= MOD;",
            "\twhile (b > 0) {",
            "\t\tif (b % 2 == 1) c = c * a % MOD;",
            "\t\ta = a * a % MOD;",
            "\t\tb /= 2;",
            "\t}",
            "\treturn c;",
            "}",
            "",
            "ll invM(ll a) { return power(a, MOD - 2); }",
            "ll nPr(int n, int r) { return (n < r) ? 0 : fact[n] * invM(fact[n - r]) % MOD; }",
            "ll nCr(int n, int r) { return (n < r) ? 0 : fact[n] * invM(fact[r]) % MOD * invM(fact[n - r]) % MOD; }"
        ],
        "description": "CP snippet with modulo arithmetic and testcases"
    },
    "take n inputs into vector": {
        "prefix": "nInputs",
        "body": [
            "vi a(n);",
            "fi(n) { cin >> a[i]; }",
            "$0"
        ],
        "description": "CP snippet for inputs to n-dimensional vector<int> a"
    },
    "sieve of Eratosthenes": {
        "prefix": "sieve",
        "body": [
            "std::vector<int> isPrime(100'000$0 + 1, 1);",
            "for (int i = 2; i * i < isPrime.size(); ++i)",
            "\tif (isPrime[i])",
            "\t\tfor (int j = i * i; j < isPrime.size(); j += i)",
            "\t\t\tisPrime[j] = 0;"
        ],
        "description": "Snippet for sieve of Eratosthenes"
    },
    "factorials": {
        "prefix": "factorials",
        "body": [
            "std::vector<int> fact(20$0 + 1, 1);",
            "fact[0] = 1;",
            "for (int i = 1; i < fact.size(); ++i) fact[i] = i * fact[i - 1];"
        ],
        "description": "Snippet for factorials without modulo"
    },
    "matrix math": {
        "prefix": "matrix",
        "body": [
            "class Mat {",
            "public:",
            "    int n, m;",
            "    std::vector<std::vector<int>> a;",
            "",
            "    Mat() {}",
            "    Mat(int nInit, int mInit)",
            "        : n(nInit), m(mInit),",
            "          a(std::vector<std::vector<int>>(n, std::vector<int>(m))) {}",
            "    Mat(std::vector<std::vector<int>> &v)",
            "        : n(v.size()), m(n ? v[0].size() : 0), a(v) {}",
            "",
            "    inline void makeIdentity() { // logically should have n == m",
            "        for (int i = 0; i < n; i++)",
            "            for (int j = 0; j < m; j++) a[i][j] = (i == j);",
            "    }",
            "    inline Mat operator+(const Mat &b) { // needs n == b.n && m == b.m",
            "        Mat ans = Mat(n, m);",
            "        for (int i = 0; i < n; i++)",
            "            for (int j = 0; j < m; j++)",
            "                ans.a[i][j] = (a[i][j] + b.a[i][j]); // % MOD;",
            "        return ans;",
            "    }",
            "    inline Mat operator-(const Mat &b) { // needs n == b.n && m == b.m",
            "        Mat ans = Mat(n, m);",
            "        for (int i = 0; i < n; i++)",
            "            for (int j = 0; j < m; j++)",
            "                ans.a[i][j] = (a[i][j] - b.a[i][j]); // + MOD) % MOD;",
            "        return ans;",
            "    }",
            "    inline Mat operator*(const Mat &b) { // needs m == b.n",
            "        Mat ans = Mat(n, b.m);",
            "        for (int i = 0; i < n; i++)",
            "            for (int j = 0; j < m; j++)",
            "                for (int k = 0; k < b.m; k++)",
            "                    ans.a[i][k] += a[i][j] * b.a[j][k];",
            "        // ans.a[i][k] = (ans.a[i][k] + 1LL * a[i][j] * b.a[j][k] % MOD) % MOD;",
            "        return ans;",
            "    }",
            "    inline Mat &operator+=(const Mat &b) { return *this = (*this) + b; }",
            "    inline Mat &operator-=(const Mat &b) { return *this = (*this) - b; }",
            "    inline Mat &operator*=(const Mat &b) { return *this = (*this) * b; }",
            "    inline bool operator==(const Mat &b) { return a == b.a; }",
            "    inline bool operator!=(const Mat &b) { return a != b.a; }",
            "    inline Mat pow(long long k) { // needs n == m",
            "        Mat ans(n, n), t(a);",
            "        ans.makeIdentity();",
            "        while (k) {",
            "            if (k % 2 != 0) ans *= t;",
            "            t *= t;",
            "            k /= 2;",
            "        }",
            "        return ans;",
            "    }",
            "};",
            "",
            "int recurrer(std::vector<std::vector<int>> f, std::vector<std::vector<int>> i, int n) {",
            "    Mat func(f), init(i);",
            "    return (func.pow(n - 1) * init).a[1][0];",
            "}"
        ],
        "description": "Snippet for matrix math"
    }
}